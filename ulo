#!/usr/bin/env bash
#
# Copyright (c) 2023 ulo
#
# Licensed under the MIT.
#
lolcat=/usr/games/lolcat

ver="1.4"
tmp="./tmp"
out="./out"
minsize=1024

# SOC
amlogic=`ls -l ./core/loader/amlogic | grep s9 | awk '{ print $9 }' | cut -d. -f1`
allwinner=`ls -l ./core/loader/allwinner | grep u-boot-sunxi-with-spl | awk '{ print $9 }' | cut -c 23- | cut -d. -f1`
rockchip=`ls -l ./core/loader/rockchip | grep idbloader | awk '{ print $9 }' | cut -c 11- | cut -d. -f1`

# Direktori path
device_path="./device"
kernel_path="./core/kernel"
rootfs_path="./rootfs"
fwdriver_path="./core/root/lib"

# Repositori dependensi ULO (Kernel, Rootfs Dasar, Driver Firmware)
ulo_repo="armarchindo/ULO-repository"

# Repositori ROOTFS kustom pada rilis
rootfs_repo="armarchindo/rootfs-openwrt"

# Atur ke 'true' untuk mengaktifkan, atau 'false' untuk menonaktifkan
DOWNLOAD_CUSTOM_KERNEL=false
DOWNLOAD_CUSTOM_ROOTFS=false

# 1. Repositori GitHub untuk kernel (format: pengguna/repo)
custom_kernel_repo="armarchindo/kernel"
# 2. Nama tag rilis tempat semua kernel berada
custom_kernel_release_tag="kernel_dbai"
# 3. Versi kernel yang ingin diunduh, pisahkan dengan spasi
custom_kernel_versions=( "6.1.66-DBAI" "5.4.279" "5.10.160-rk35v-dbai" "6.1.31-AW64-DBAI" "6.1.104-AW64-DBAI" "6.6.6-AW64-DBAI" "6.1.123" )

selected_patch=""

start_cnt=$SECONDS

die() {
    echo -e "ERROR.. = $1"
    exit 1
}

download_and_extract_custom_kernels() {
    if [ "$DOWNLOAD_CUSTOM_KERNEL" = false ]; then
        echo "Pengunduhan kernel kustom dinonaktifkan. Melewati..."
        return
    fi

    if [ ${#custom_kernel_versions[@]} -eq 0 ]; then
        echo "Tidak ada versi kernel yang ditentukan di 'custom_kernel_versions', proses dilewati."
        return
    fi

    echo "Mengambil daftar kernel dari rilis '$custom_kernel_release_tag'..." | $lolcat
    
    local api_url="https://api.github.com/repos/$custom_kernel_repo/releases/tags/$custom_kernel_release_tag"
    
    local assets_info=$(curl -s "$api_url" | jq -r '.assets[] | "\(.name) \(.browser_download_url)"')

    if [ -z "$assets_info" ]; then
        echo "ERROR: Gagal mengambil daftar aset. Periksa nama repositori dan tag rilis."
        return
    fi

    echo "Memulai pengunduhan kernel kustom..." | $lolcat -a -d 5
    
    local temp_download_dir="./tmp_kernels_dl"
    mkdir -p "$temp_download_dir"

    for version in "${custom_kernel_versions[@]}"; do
        local archive_name="${version}.tar.gz"
        local extract_dir="${kernel_path}/${version}"

        local download_url=$(echo "$assets_info" | grep "^${archive_name} " | awk '{print $2}')

        echo "----------------------------------------"
        
        if [ -z "$download_url" ]; then
            echo "-> PERINGATAN: Kernel '${archive_name}' tidak ditemukan di aset rilis. Dilewati."
            continue
        fi

        echo "-> Mengunduh: ${archive_name}" | $lolcat

        if aria2c --console-log-level=warn --dir="$temp_download_dir" -o "$archive_name" "$download_url"; then
            echo "-> Mengekstrak ${archive_name} ke ${extract_dir}/"
            mkdir -p "$extract_dir"
            
            if tar -xzf "${temp_download_dir}/${archive_name}" -C "$extract_dir/" --strip-components=1; then
                echo "   Ekstraksi berhasil."
            else
                echo "   ERROR: Gagal mengekstrak ${archive_name}."
            fi
        else
            echo "   ERROR: Gagal mengunduh ${archive_name}."
        fi
    done

    rm -rf "$temp_download_dir"
    echo "----------------------------------------"
    echo "Proses pengunduhan kernel kustom selesai." | $lolcat -a -d 5
}

check_depedencies() {
    local pkgs_to_install=()
    req=(lolcat pigz aria2 wget jq unrar)

    if command -v pacman &>/dev/null; then
        lolcat="/usr/bin/lolcat" # Perbarui path lolcat untuk Arch Linux
        req+=(p7zip)
        for pkg in "${req[@]}"; do
            pacman -Qq "$pkg" &>/dev/null || pkgs_to_install+=("$pkg")
        done
    else
        req+=(p7zip-full)
        for pkg in "${req[@]}"; do
            dpkg -s "$pkg" &>/dev/null || pkgs_to_install+=("$pkg")
        done
    fi

    if [ ${#pkgs_to_install[@]} -gt 0 ]; then
        echo -e "Mempersiapkan instalasi dependensi..."
        
        if command -v pacman &>/dev/null; then
            for pkg in "${pkgs_to_install[@]}"; do
                echo "  Menginstal $pkg..."
                sudo pacman -S --noconfirm "$pkg" > /dev/null 2>&1
            done
        else
            for pkg in "${pkgs_to_install[@]}"; do
                echo "  Menginstal $pkg..."
                sudo apt-get -y install "$pkg" > /dev/null 2>&1
            done
        fi
        
        echo -e "Selesai!!!"
    fi
}

custom_rootfs_files() {
    if [ "$DOWNLOAD_CUSTOM_ROOTFS" = false ]; then
        echo "Pengunduhan ROOTFS kustom dinonaktifkan. Melewati..."
        return
    fi

    echo -e "Apakah Anda ingin menambahkan ROOTFS tambahan? (Y/N)" | $lolcat -a -d 5
    local optz=$1
    local opt=""
    local long_url="https://api.github.com/repos/$rootfs_repo/releases"
    echo -e "$optz"
    if [ "$optz" = "yes" ]; then
        opt="Y"
    elif [ "$optz" = "no" ]; then
        opt="N"
    else
        read -p "" opt
    fi
    if [ "$opt" = "y" ] || [ "$opt" = "Y" ]; then
        echo -e "Mengunduh file ROOTFS..." | $lolcat -a -d 5
        local cnt=0
        local json_data=`curl -s $long_url`
        local list_url=`echo $json_data | jq -r '.[].assets[].browser_download_url'`
        local list_name=`echo $json_data | jq '.[].tag_name' | tr -d '"'`
        local list_files=`echo $json_data | jq '.[].assets[].name' | tr -d '"'`
        for names in ${list_name[*]}; do
            ((cnt++))
            echo -e "$cnt. $names"
        done
        for urls in ${list_url[*]}; do
            echo "Mengunduh $(basename "$urls")..."
            aria2c --console-log-level=warn -d rootfs "$urls"
        done
    else
        echo -e "ROOTFS kustom dilewati..."
    fi
    echo -e "Selesai...!!!"
}

check_requirement_files() {
    statx=0
    find_devices
    find_rootfs
    find_kernels
    [ ${#devices[*]} = 0 ] && die "Tidak ada file atau direktori ${device_path:2}!"
    [ ${#rootfs[*]} = 0 ] && statx=1
    [ ${#kernels[*]} = 0 ] && statx=2
    [ -d "${fwdriver_path}/firmware" ] || statx=3
    if [ $statx = 1 ]; then
        echo -e "File ROOTFS tidak tersedia!"
        download_requirement_files false
    elif [ $statx = 2 ]; then
        echo -e "File dependensi ULO-Builder tidak ditemukan!"
        download_requirement_files false
    elif [ $statx = 3 ]; then
        echo -e "Dependensi ULO tidak ditemukan!"
        download_requirement_files false
    fi
}

download_requirement_files() {
    local tmp_path="./tmp"
    local cmd=$1
    if [ $cmd = true ]; then
        rm -rf ./core/kernel/*
        rm -rf ./rootfs/*
        rm -rf $fwdriver_path/firmware
    fi
    [ -d "${tmp_path}" ] || mkdir $tmp_path

    if [ ! -f "${tmp_path}/data.zip" ]; then
        echo -e "Mengunduh KERNEL, ROOTFS, & Driver Firmware" | $lolcat -a -d 1
        aria2c --console-log-level=warn --out=${tmp_path}/data.zip "https://github.com/${ulo_repo}/archive/refs/heads/main.zip"
        echo -e "Mengekstrak KERNEL, ROOTFS, & Driver Firmware" | $lolcat -a -d 1
        unzip -q $tmp_path/data.zip -d $tmp_path
        cp -rf $tmp_path/ULO-repository-main/kernel ./core/
        cp -rf $tmp_path/ULO-repository-main/rootfs ./
        cp -rf $tmp_path/ULO-repository-main/firmware $fwdriver_path/
        echo -e "Selesai..." | $lolcat -a -d 5
        rm -r $tmp_path
    fi
    echo -e "Semua file yang diperlukan sudah ada." | $lolcat -a -d 1
    
    download_and_extract_custom_kernels
    custom_rootfs_files
    find_devices
    find_rootfs
    find_kernels
}

cleaning() {
    for x in $(lsblk | grep $(pwd) | grep -oE 'loop[0-9]+' | sort | uniq); do
        umount -f /dev/${x}p[1-2] 2>/dev/null
        umount -f /dev/$x 2>/dev/null
        losetup -d /dev/$x 2>/dev/null
        losetup -D 2>/dev/null
    done
    rm -rf $tmp
    [ "$1" ] || rm -rf $out
}

kernel_checker() {
    local kernelx=$1
    local cmdx=$2
    local is_amlogic=false
    local is_allwinner=false
    local is_rockchip=false
    local kinfo=`ls core/kernel/${kernelx} | grep dtb | cut -d- -f2`

    echo $amlogic | grep -iq $device && is_amlogic=true
    echo $allwinner | grep -iq $device && is_allwinner=true
    echo $rockchip | grep -iq $device && is_rockchip=true
    
    if [ $is_amlogic = true ] && [ $kinfo = "amlogic" ]; then
        [ $cmdx = false ] && echo -e "${kernel}\n" | $lolcat -a -d 5
    elif [ $is_allwinner = true ] && [ $kinfo = "allwinner" ]; then
        [ $cmdx = false ] && echo -e "${kernel}\n" | $lolcat -a -d 5
    elif [ $is_rockchip = true ] && [ $kinfo = "rockchip" ]; then
        [ $cmdx = false ] && echo -e "${kernel}\n" | $lolcat -a -d 5
    elif [ $cmdx = true ]; then
        die "Kernel ini untuk perangkat ${kinfo}!!!"
    else
        echo "Kernel ini untuk perangkat ${kinfo}!!!"
        echo "Silakan pilih ulang"
        find_kernels
        choose_kernel
    fi
}

find_devices() {
    local path=$device_path
    [ -d $path ] || return
    local len=0
    IFS=$'\n'
    for x in $(ls $path); do
        [ -f $path/$x/boot-*.tar.gz ] && devices[len++]=$x
    done
}

find_kernels() {
    local path=$kernel_path
    [ -d $path ] || return
    local len=0
    IFS=$'\n'
    kernels=()
    for x in $(ls $path); do
        if [ -d "$path/$x" ]; then
            if [ -n "$(ls "$path/$x"/dtb-*.tar.gz 2>/dev/null)" ] && \
               [ -n "$(ls "$path/$x"/boot-*.tar.gz 2>/dev/null)" ] && \
               [ -n "$(ls "$path/$x"/modules-*.tar.gz 2>/dev/null)" ]; then
                kernels[len++]=$x
            fi
        fi
    done
}

find_rootfs() {
    local path=$rootfs_path
    [ -d $path ] || return
    local len=0
    IFS=$'\n'
    for x in $(ls $path); do
        rootfs[len++]=$x
    done
}

choose_device() {
    local i=0
    echo -e "Chipset: " | $lolcat -a -d 5
    choose_option ${#devices[@]} "" "${devices[@]}"
    local opt=$?
    device=${devices[opt]}
    devices=($device)
    echo -e "${device}\n" | $lolcat -a -d 5
}

choose_rootfs() {
    local i=0
    echo -e "ROOTFS: " | $lolcat -a -d 5
    choose_option ${#rootfs[@]} "" "${rootfs[@]}"
    local opt=$?
    firmware=${rootfs[opt]}
    echo -e "${firmware}\n" | $lolcat -a -d 5
    echo $firmware > $rootfs_path/rootfs.log
}

choose_kernel() {
    local i=0
    local filtered_kernels=()

    for kernel in "${kernels[@]}"; do
        local kinfo=$(ls "core/kernel/${kernel}" | grep dtb | cut -d- -f2)
        if [ "$kinfo" = "amlogic" ] && echo $amlogic | grep -iq $device; then
            filtered_kernels+=("$kernel")
        elif [ "$kinfo" = "allwinner" ] && echo $allwinner | grep -iq $device; then
            filtered_kernels+=("$kernel")
        elif [ "$kinfo" = "rockchip" ] && echo $rockchip | grep -iq $device; then
            filtered_kernels+=("$kernel")
        fi
    done

    echo -e "Kernel:" | $lolcat -a -d 5
    choose_option ${#filtered_kernels[@]} "kernel" "${filtered_kernels[@]}"
    local opt=$?
    kernel=${filtered_kernels[opt]}
    kernels=($kernel)
    kernel_checker "${kernel}" false
}

choose_patch() {
    local patch_path="./patch"
    if [ ! -d "$patch_path" ]; then
        echo "Direktori 'patch' tidak ditemukan. Melewati..."
        return
    fi

    local patches=()
    for p in $(find "$patch_path" -maxdepth 1 -type f); do
        patches+=("$(basename "$p")")
    done

    if [ ${#patches[@]} -eq 0 ]; then
        echo "Tidak ada patch arsip yang ditemukan di direktori 'patch'. Melewati..."
        return
    fi

    local options=("Lewati (Tidak ada patch)" "${patches[@]}")

    echo -e "Pilih patch yang akan diterapkan:" | $lolcat -a -d 5
    choose_option ${#options[@]} "" "${options[@]}"

    local opt=$?
    if [ $opt -ne 0 ]; then
        selected_patch=${options[$opt]}
        echo -e "Patch dipilih: ${selected_patch}\n" | $lolcat -a -d 5
    else
        selected_patch=""
        echo -e "Patch dilewati.\n"
    fi
}

choose_option() {
    local len=$1
    local optx=$2
    shift 2
    local options=("$@")
    local i=0

    if [ "$optx" != "kernel" ]; then
        for x in "${options[@]}"; do
            echo -e "($((++i))) => $x"
        done
    else
        for x in "${options[@]}"; do
            local kinfo=$(ls "core/kernel/${x}" | grep dtb | cut -d- -f2)
            if [ "$kinfo" = 'amlogic' ]; then
                kinfo='Amlogic  '
            elif [ "$kinfo" = 'allwinner' ]; then
                kinfo='AllWinner'
            elif [ "$kinfo" = 'rockchip' ]; then
                kinfo='Rockchip '
            else
                kinfo='Undefined'
            fi
            echo -e "($((++i))) => $kinfo $x"
        done
    fi

    [ "$len" = 1 ] && return 0

    local cnt=0
    while [ $cnt -lt 3 ]; do
        echo "Pilih Nomor:" | $lolcat -a -d 5
        read -p "" opt
        if [ ! "$opt" ]; then
            opt=0
            break
        elif [[ "$opt" -ge 1 && "$opt" -le "$len" ]] 2>/dev/null; then
            ((opt--))
            break
        else
            ((cnt++))
            echo -e "Salah pilih ulo.."
            sleep 1s
        fi
    done

    [ $cnt = 3 ] && die "Bye NooB...!!!"
    return $opt
}

make_losetup() {
    local path=$1
    loop=$(losetup -Pf --show $path)
    [ $loop ] || die "Error... ${path:2}"

    [ $2 ] && return 0

    loop_seq=$(ls $loop | grep -oE 'loop[0-9]+')

    mount="$tmp/mount"
    mkdir -p $mount

    [ -e ${loop}p1 ] && {
        mkdir -p $mount/${loop_seq}p1
        mount ${loop}p1 $mount/${loop_seq}p1
    }
    [ -e ${loop}p2 ] && {
        mkdir -p $mount/${loop_seq}p2
        mount ${loop}p2 $mount/${loop_seq}p2
    }
    
    [[ ! -e ${loop}p1 && ! -e ${loop}p2 && -e ${loop} ]] && {
        mkdir -p $mount/${loop_seq}
        mount ${loop} $mount/${loop_seq}
    }
}

apply_patch() {
    if [ -z "$selected_patch" ]; then
        return
    fi

    local patch_file="./patch/$selected_patch"
    local rootfs_target="$common_root"

    echo "Menerapkan patch: $selected_patch..." | $lolcat -a -d 5

    echo "Tipe patch: Arsip. Mengekstrak file..."
    case "$patch_file" in
        *.zip)
            unzip -o "$patch_file" -d "$rootfs_target" >/dev/null 2>&1
            ;;
        *.rar)
            unrar x -o+ "$patch_file" "$rootfs_target/" >/dev/null 2>&1
            ;;
        *.tar.gz|*.gz|*.tar.xz|*.xz)
            tar xf "$patch_file" -C "$rootfs_target"
            ;;
        *.7z)
            7z x "$patch_file" -o"$rootfs_target" -y >/dev/null 2>&1
            ;;
        *)
            echo "Peringatan: Format arsip '$selected_patch' tidak dikenali. Dilewati."
            return
            ;;
    esac
    echo "Patch arsip selesai diterapkan." | $lolcat
}

unpack_openwrt() {
    local path="$rootfs_path/$firmware"
    local suffix="${firmware##*.}"
    common_root="$tmp/core/root"
    start_build=$SECONDS

    mkdir -p $common_root

    while true; do
        case "$suffix" in
            xz)
                xz -dc $path > $tmp/${firmware%.*}
                path=$tmp/${firmware%.*}
                suffix=${path##*.}
            ;;
            gz) 
                if ls $path | grep -q '.tar.gz$'; then
                    tar xzf $path -C $common_root
                    break
                else
                    gzip -dc $path > $tmp/${firmware%.*}
                    path=$tmp/${firmware%.*}
                    suffix=${path##*.}
                fi
            ;;
            img|ext4)
                make_losetup $path
                if [ -d $mount/${loop_seq}p2 ]; then
                    cp -r $mount/${loop_seq}p2/* $common_root
                elif [ -d $mount/${loop_seq}p1 ]; then
                    cp -r $mount/${loop_seq}p1/* $common_root
                elif [ -d $mount/${loop_seq} ]; then
                    cp -r $mount/${loop_seq}/* $common_root
                else
                    die "error unpack $path"
                fi
                break
            ;;
            *)
                die "Format error!"
            ;;
        esac
    done
    
    apply_patch

    rm -rf $common_root/lib/modules/*/
}

unpack_boot_kernel() {
    local path="$kernel_path/$kernel"
    common_boot="$tmp/core/kernel/$kernel/boot"
    last_device="$tmp/device/$device"

    local is_amlogic=false
    local is_allwinner=false
    local is_rockchip=false

    echo $amlogic | grep -iq $device && is_amlogic=true
    echo $allwinner | grep -iq $device && is_allwinner=true
    echo $rockchip | grep -iq $device && is_rockchip=true

    mkdir -p $common_boot
    tar xzf $path/boot-*.tar.gz -C $common_boot 2>/dev/null

    if [ $is_amlogic = true ]; then
        mkdir -p ${last_device}/$kernel/{boot,boot/dtb,boot/dtb/amlogic,root,root/lib/modules}
        tar xzf $kernel_path/$kernel/dtb-*.tar.gz -C ${last_device}/$kernel/boot/dtb/amlogic
    elif [ $is_allwinner = true ]; then
        mkdir -p ${last_device}/$kernel/{boot,boot/dtb,boot/dtb/allwinner,root,root/lib/modules}
        tar xzf $kernel_path/$kernel/dtb-*.tar.gz -C ${last_device}/$kernel/boot/dtb/allwinner
    elif [ $is_rockchip = true ]; then
        mkdir -p ${last_device}/$kernel/{boot,boot/dtb,boot/dtb/rockchip,root,root/lib/modules}
        tar xzf $kernel_path/$kernel/dtb-*.tar.gz -C ${last_device}/$kernel/boot/dtb/rockchip
    fi
    
    cp -r $common_boot/* ${last_device}/$kernel/boot
    cp -r $common_root/* ${last_device}/$kernel/root

    tar xzf $device_path/$device/boot-$device.tar.gz -C ${last_device}/$kernel/boot
    tar xzf $path/modules-*.tar.gz -C ${last_device}/$kernel/root/lib/modules
    (cd $tmp/device/$device/$kernel/root/lib/modules/$kernel/ && rm -f build source *.ko 2>/dev/null &&
    find ./ -type f -name '*.ko' -exec ln -s {} ./ \;)

    [ $(ls $device_path/$device/root | wc -l) = 0 ] || cp -r $device_path/$device/root/* ${last_device}/$kernel/root
    [ $(ls ./core/root | wc -l) = 0 ] || cp -r ./core/root/* ${last_device}/$kernel/root
}

make_image() {
    local image="$out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img"
    [ -d $out/$device ] || mkdir -p $out/$device

    fallocate -l $((16 + 256 + rootsize))M $image

    parted -s $image mklabel msdos
    parted -s $image mkpart primary fat32 17M 273M
    parted -s $image mkpart primary ext4 273M 100%

    make_losetup $image 1

    local is_amlogic=false
    echo $amlogic | grep -iq $device && is_amlogic=true
    local is_rockchip=false
    echo $rockchip | grep -iq $device && is_rockchip=true
    local is_allwinner=false
    echo $allwinner | grep -iq $device && is_allwinner=true

    mkfs.vfat -n "BOOT" ${loop}p1 >/dev/null 2>&1
    mke2fs -F -q -t ext4 -L "ROOTFS" -m 0 ${loop}p2 >/dev/null 2>&1

    txtloader=""
    if [ $is_amlogic = true ]; then
        # AMLOGIC DEVICES BOOTLOADER
        loader="./core/loader/amlogic/${device}.bin"
        txtloader="${device}.bin"
        dd if=$loader of=$loop bs=1 count=444 conv=fsync 2>/dev/null
        dd if=$loader of=$loop bs=512 skip=1 seek=1 conv=fsync 2>/dev/null
    fi

    if [ $is_allwinner = true ]; then
        # ALLWINNER DEVICES BOOTLOADER
        loader="./core/loader/allwinner/u-boot-sunxi-with-spl-${device}.bin"
        loader1="./core/loader/allwinner/u-boot-mainline-${device}.bin"

        dd if=$loader of=$loop bs=8k seek=1 conv=fsync,notrunc 2>/dev/null
        if [ -f ${loader} ]; then
            dd if=$loader of=$loop bs=8k seek=1 conv=fsync,notrunc 2>/dev/null
            txtloader="${txtloader}u-boot-sunxi-with-spl-${device}.bin"
        fi
        if [ -f ${loader1} ]; then
            dd if=$loader1 of=$loop bs=8k seek=5 conv=fsync,notrunc 2>/dev/null
            txtloader="${txtloader} | u-boot-mainline-${device}.bin"
        fi
    fi
    
    if [ $is_rockchip = true ]; then
        # ROCKCHIP DEVICES BOOTLOADER
        loader="./core/loader/rockchip/idbloader-${device}.img"
        loader1="./core/loader/rockchip/u-boot-${device}.itb"
        loader2="./core/loader/rockchip/trust-${device}.bin"

        if [ -f ${loader} ]; then
            dd if=$loader of=$loop conv=fsync,notrunc bs=512 seek=64 2>/dev/null
            txtloader="${txtloader}idbloader-${device}.img"
        fi
        if [ -f ${loader1} ]; then
            dd if=$loader1 of=$loop conv=fsync,notrunc bs=512 seek=16384 2>/dev/null
            txtloader="${txtloader} | u-boot-${device}.itb"
        fi
        if [ -f ${loader2} ]; then
            dd if=$loader2 of=$loop conv=fsync,notrunc bs=512 seek=24576 2>/dev/null
            txtloader="${txtloader} | trust-${device}.bin"
        fi
    fi

    echo $txtloader > $rootfs_path/uboot.log
    losetup -d ${loop}

    make_losetup $image

    {
        set -e
        cp -r ${last_device}/$kernel/boot/* $mount/${loop_seq}p1
        cp -r ${last_device}/$kernel/root/* $mount/${loop_seq}p2

        (
            cd $mount/${loop_seq}p1
                if [ $is_allwinner = true ]; then
                    cp uInitrd-* uInitrd
                    cp vmlinuz-* Image
                elif [ $is_rockchip = true ]; then
                    cp uInitrd-* uInitrd
                    cp vmlinuz-* Image
                elif [ $is_amlogic = true ]; then
                    mv uInitrd-* uInitrd
                    mv vmlinuz-* zImage
                fi
        )

        lain_lain "$mount/${loop_seq}p2"
    }
}

lain_lain() {
    local path=$1
    
    [ -d $path ] && {
        mkdir -p $path/{boot,opt,run}

        local is_amlogic=false
        local is_allwinner=false
        local is_rockchip=false

        echo $amlogic | grep -iq $device && is_amlogic=true
        echo $allwinner | grep -iq $device && is_allwinner=true
        echo $rockchip | grep -iq $device && is_rockchip=true

        if [ $is_amlogic = true ]; then
            printf 'pwm_meson' > $path/etc/modules.d/pwm-meson
            sed -i 's/ttyAMA0/ttyAML0/' $path/etc/inittab
            sed -i 's/ttyS0/tty0/' $path/etc/inittab

            if ! grep -q '/tmp/upgrade' $path/etc/init.d/boot; then
                sed -i '/kmodloader/i\\tmkdir -p \/tmp\/upgrade' $path/etc/init.d/boot
            fi
        elif [ $is_allwinner = true ]; then
            sed -i 's/ttyAMA0/tty1/' $path/etc/inittab
            sed -i 's/ttyS0/ttyS2/' $path/etc/inittab
        elif [ $is_rockchip = true ]; then
            sed -i 's/ttyAMA0/tty1/' $path/etc/inittab
            sed -i 's/ttyS0/ttyS2/' $path/etc/inittab
        fi

        if ! grep -q 'ulimit -n' $path/etc/init.d/boot; then
            sed -i '/kmodloader/i\\tulimit -n 131072\n' $path/etc/init.d/boot
        fi
        
        wireless_mac80211="$path/lib/netifd/wireless/mac80211.sh"
        [[ -f "${wireless_mac80211}" ]] && {
            cp -f ${wireless_mac80211} ${wireless_mac80211}.bak
            sed -i "s|iw |ipconfig |g" ${wireless_mac80211}
        }
 
        rm -rf $path/lib/firmware/
        cp -rf $fwdriver_path/firmware $path/lib/
        chmod 777 $path/lib/firmware/*
        chown -R 0:0 $path
    }
}

set_rootsize() {
    local cnt=0

    while [ $cnt -lt 3 ]; do
        echo "Ukuran rootfs Anda" | $lolcat -a -d 5
        echo "Masukkan angka (256 512 640 768 1024 1536) default ${minsize}" | $lolcat -a -d 5
        read -p "" rootsize
        if [ ! "$rootsize" ]; then
            rootsize=$minsize
            break
        elif [[ "$rootsize" -ge "256" ]] 2>/dev/null; then
            break
        else
            ((cnt++))
            echo -e "Salah ulo...\n"
            sleep 1s
        fi
    done

    [ $cnt = 3 ] && die "Bye NooB..."
}

extract_kernel() {
    choose_rootfs

    local path="$rootfs_path/$firmware"
    local suffix="${firmware##*.}"

    while true; do
        case "$suffix" in
            xz)
                [ -d $tmp ] || mkdir -p $tmp
                echo -e "unpack"
                xz -dc $path > $tmp/${firmware%.*}
                path=$tmp/${firmware%.*}
                suffix=${path##*.}
            ;;
            img)
                make_losetup $path
                break
            ;;
            *)
                die "Format error!"
            ;;
        esac
    done

    local kversion=$(ls $mount/${loop_seq}p2/lib/modules)
    local version=$(echo $kversion | grep -oE '^[4-5].[0-9]+.[0-9]+')

    echo -e "kernel version  =>  $kversion"

    mkdir -p $tmp/$version/{boot,boot/dtb,boot/dtb/amlogic,root/lib}
    cp -r $mount/${loop_seq}p1/{config-*,initrd.img-*,System.map-*,uInitrd-*,vmlinuz-*} $tmp/$version/boot
    cp -r $mount/${loop_seq}p2/lib/modules $tmp/$version/root/lib/modules/*

    (
        cd $tmp/$version/root/lib/modules/*/
        rm -rf *.ko
        find ./ -type f -name '*.ko' -exec ln -s {} ./ \;
    )

    if [ $is_amlogic = true ]; then
        echo -e "package\t\t=>  dtb-*.tar.gz"
        cd $tmp/$version/boot/dtb/amlogic
        tar czf dtb-*.tar.gz * dtb/amlogic
        mv dtb-*.tar.gz ../
    elif [ $is_allwinner = true ]; then    
        echo -e "package\t\t=>  dtb-*.tar.gz"
        cd $tmp/$version/boot/dtb/allwinner
        tar czf dtb-*.tar.gz * dtb/allwinner
        mv dtb-*.tar.gz ../
    elif [ $is_rockchip = true ]; then    
        echo -e "package\t\t=>  dtb-*.tar.gz"
        cd $tmp/$version/boot/dtb/rockchip
        tar czf dtb-*.tar.gz * dtb/rockchip
        mv dtb-*.tar.gz ../
    fi
        
    (
        echo -e "package\t\t=>  boot-$version.tar.gz"
        cd $tmp/$version/boot
        tar czf boot-$version.tar.gz *
        mv boot-$version.tar.gz ../
    )

    (
        echo -e "package\t\t=>  modules-$version.tar.gz"
        cd $tmp/$version/root
        tar czf modules-$version.tar.gz lib/
        mv modules-$version.tar.gz ../
    )

    rm -rf $tmp/$version/{boot,root}

    [ -f $tmp/$version/boot-$version.tar.gz ] && [ -f $tmp/$version/modules-$version.tar.gz ] && {
        [ -d $kernel_path/$version ] && {
            echo && read -p "this version $(echo -e "${version}") Replace? [Y/n] " yn && echo 
            case "$yn" in
                n|N) yn=n ;;
                *) yn=y ;;
            esac
        }
        [[ ! "$yn" || "$yn" = "y" ]] && {
            [ -d $kernel_path ] || mkdir -p $kernel_path
            cp -r $tmp/$version $kernel_path
            chown -R 1000:1000 $kernel_path/$version
            echo -e "done"
        }
    }

    cleaning
}

mount_image() {
    choose_rootfs

    local path="$rootfs_path/$firmware"
    local suffix="${firmware##*.}"

    while true; do
        case "$suffix" in
            xz)
                [ -d $tmp ] || mkdir -p $tmp
                echo -e "unpack"
                xz -dc $path > $tmp/${firmware%.*}
                path=$tmp/${firmware%.*}
                suffix=${path##*.}
            ;;
            img)
                make_losetup $path
                break
            ;;
            *)
                die "Format error!"
            ;;
        esac
    done

    echo -e "success mounted to ${mount:2}/${loop_seq}"
}

usage() {
    cat <<-EOF
Penggunaan:
  ulo [opsi]

Opsi:
    -h, --help      : Menampilkan teks ini
    -c, --clean     : Membersihkan cache lama
    -u, --update    : Memperbarui Kernel, ROOTFS, dan file Firmware dari ULO-Repository
                      (Akan menghapus Kernel, ROOTFS, dan file Firmware lama!!!)
    -y  --yes       : Unduh ROOTFS kustom
    -k              : Atur kernel       (-k 6.1.66-DBAI)
    -m              : Atur perangkat    (-m s905x2)
    -r              : Atur file rootfs  (-r immortalwrt-21.02.7-vanila-armvirt-64-default-rootfs.tar.gz)
    -s, --size=SIZE : Atur ukuran       (-s 1024)

EOF
}

[ $(id -u) = 0 ] || die "Jalankan skrip ini sebagai root"

check_depedencies

echo -e "
======================================================================
----------------------------------------------------------------------
                            ULO BUILDER 
                               v${ver}
                              By DBAI
----------------------------------------------------------------------
======================================================================
" | $lolcat -a -d 5

check_requirement_files

while [ "$1" ]; do
    case "$1" in
        -y|--yes)
            custom_rootfs_files "yes"
            exit
        ;;
        -h|--help)
            usage
            exit
        ;;
        -c|--clean)
            cleaning
            echo -e "Pembersihan selesai"
            exit
        ;;
        -u|--update)
            echo -e "Memperbarui Kernel, ROOTFS, dan file Firmware dari ULO-Repository"
            download_requirement_files true
            exit
        ;;
        -d|--default)
            : ${device:="all"}
            : ${firmware:=${rootfs[0]}}
            : ${kernel:="all"}
            : ${rootsize:=$minsize}
        ;;
        -e)
            extract_kernel
            exit
        ;;
        -k)
            kernel=$2
            if [ -f $kernel_path/$kernel/dtb-*.tar.gz ] && \
               [ -f $kernel_path/$kernel/boot-*.tar.gz ] && \
               [ -f $kernel_path/$kernel/modules-*.tar.gz ]; then
                kernels=($kernel)
                kernel_checker "${kernels}" true
                shift
            else
                die "kernel tidak valid $kernel"
            fi
        ;;
        -m)
            device=$2
            if [ -f $device_path/$device/boot-*.tar.gz ]; then
                devices=($device)
                shift
            elif [ "$device" = "all" ]; then
                [ ${#devices[*]} = 0 ] && unset device
                shift
            else
                die "perangkat tidak valid $device"
            fi
        ;;
        -r)
            rootf=$2
            if [ -f $rootfs_path/$rootf ]; then
                firmware=($rootf)
                echo $firmware > $rootfs_path/rootfs.log
                shift
            else
                die "rootfs tidak valid $rootf"
            fi
        ;;
        --mount)
            mount_image
            exit
        ;;
        -s|--size)
            rootsize=$2
            if [[ "$rootsize" -ge "$minsize" ]] 2>/dev/null; then
                shift
            else
                die "ukuran rootfs tidak valid $rootsize"
            fi
        ;;
        *)
            usage
            die "opsi tidak valid $1"
        ;;
    esac
    shift
done

[ "$device" ] && {
    echo -en "perangkat\t=>  "
    echo -e "${devices[@]}" | sed 's/ /, /g'
}
[ "$firmware" ] && {
    echo -en "rootfs\t\t=>  "
    echo -e "${firmware[@]}" | sed 's/ /, /g'
}
[ "$kernel" ] && {
    echo -en "kernel\t\t=>  "
    echo -e "${kernels[@]}" | sed 's/ /, /g'
}
[ "$rootsize" ] && echo -e "ukuran rootfs\t=>  $rootsize"
[ "$device" ] || [ "$firmware" ] || [ "$kernel" ] || [ "$rootsize" ] && echo 

[ "$device" ] || choose_device
[ "$firmware" ] || choose_rootfs
[ "$kernel" ] || choose_kernel
choose_patch
[ "$rootsize" ] || set_rootsize

unpack_openwrt
echo "Sedang membangun..." | $lolcat -a -d 5

for kernel in ${kernels[*]}; do
    for device in ${devices[*]}; do
    {
        unpack_boot_kernel
        make_image
    } &
    done
done

wait
Total_size="$((256+$rootsize))"
uboot=$(cat ${rootfs_path}/uboot.log | cut -d '/' -f5-6)

echo -e "Informasi Build:
    Perangkat   = $device
    Kernel      = $kernel
    Rootfs      = $(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)
    Ukuran      = $Total_size M
    U-boot      = ${uboot}" | $lolcat -a -d 5
echo "    Lokasi Firmware = out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img.gz" | $lolcat -a -d 5
cleaning 0

pigz -qf $out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img || gzip $out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img
tot_time=$(($SECONDS - $start_cnt))
build_time=$(($SECONDS - $start_build))

echo "    Waktu Build = $(($build_time/60))m $(($build_time%60))s" | $lolcat -a -d 5
echo "    Total Waktu = $(($tot_time/60))m $(($tot_time%60))s" | $lolcat -a -d 5
echo -e 'Selesai...' | $lolcat -a -d 5
echo -e ""

read -p "Apakah Anda ingin menulis Firmware ke disk? (Y/N): " burn_opt
if [[ "$burn_opt" =~ ^[Yy]$ ]]; then
    gnome-disks --restore-disk-image="$out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img"
fi

chmod -R 777 $out
rm $rootfs_path/uboot.log
rm $rootfs_path/rootfs.log